import copy
import importlib
import json
import os
from pathlib import Path
from typing import List, Dict, Iterable

from otlmow_converter.DotnotationHelper import DotnotationHelper
from otlmow_converter.OtlmowConverter import OtlmowConverter
from otlmow_model.OtlmowModel.BaseClasses.FloatOrDecimalField import FloatOrDecimalField
from otlmow_model.OtlmowModel.BaseClasses.KeuzelijstField import KeuzelijstField
from otlmow_model.OtlmowModel.BaseClasses.OTLObject import OTLObject, dynamic_create_instance_from_uri, create_dict_from_asset, set_value_by_dictitem

from otlmow_postenmapping.Exceptions.InvalidMappingKeyError import InvalidMappingKeyError
from otlmow_postenmapping.Exceptions.MultipleMappingKeysError import MultipleMappingKeysError
from otlmow_postenmapping.Exceptions.MissingMappingKeyError import MissingMappingKeyError
from otlmow_postenmapping.PostenMappingTemplateModifier import PostenMappingTemplateModifier, create_dummy_assets


from otlmow_postenmapping.SQLDbReader import SQLDbReader


class PostAssetFactory:
    mapping_dict = None

    def __init__(self, mapping_artefact_path: Path = None, directory: Path = None,
                 mapping_name: str = 'PostenMapping') -> None:
        self.mapping_dict = None
        if mapping_artefact_path is not None:
            if not os.path.isfile(mapping_artefact_path):
                raise FileNotFoundError(f'{mapping_artefact_path} is not a valid path. File does not exist.')
            self.mapping_dict = self._write_and_return_mapping_dict(mapping_artefact_path, directory=directory,
                                                                    mapping_name=mapping_name)

        if self.mapping_dict is None:
            self.mapping_dict = self.import_mapping_dict(directory=directory, mapping_name=mapping_name)

    @staticmethod
    def import_mapping_dict(directory: Path, mapping_name: str):
        class_name = f'{mapping_name}Dict'
        import_str = class_name
        if directory is not None:
            import_str = f'{directory}.{import_str}'
        py_mod = importlib.import_module(import_str)
        class_ = getattr(py_mod, class_name)
        return class_().mapping_dict

    def get_valid_mapping_key_from_base_asset(self, base_asset: OTLObject) -> str:
        """Obtain mapping key

        Searches in the "PostenMapping dictionary" for the "PostenMapping key"
        that matches with the "BestekPost nummer"

        Parameters
        ----------
        base_asset : OTLObject
            The base asset, from which a "BestekPost nummer" is derived.

        Returns
        -------
        str
            The valid "PostenMapping key"
        """
        bestek_post_nummer = base_asset.bestekPostNummer

        if not bestek_post_nummer:
            raise MissingMappingKeyError("bestekPostNummer is missing or empty in the base asset")

        valid_keys = {
            candidate_key
            for candidate_key in bestek_post_nummer
            if candidate_key in self.mapping_dict
        }

        number_valid_keys = len(valid_keys)
        if number_valid_keys == 0:
            raise InvalidMappingKeyError(
                "bestekPostNummer(s) not found in posten mapping dictionary"
            )
        elif number_valid_keys > 1:
            raise MultipleMappingKeysError("Multiple values found for bestekPostNummer; expected one.")
        return list(valid_keys)[0]

    def create_assets_from_mapping_and_write_to_file(self, start_assets: Iterable[OTLObject],
                                                     output_path: Path,
                                                     keep_original_attributes: bool = True,
                                                     append_all_attributes: bool = True,
                                                     model_directory: Path = None):
        """Create assets from a mapping template (step 1) and write the assets to an Excel file (step 2)

        Call the appropriate functions:
        - PostAssetFactory.create_assets_from_mapping
        - PostAssetFactory.create_dummy_assets
        - OtlmowConverter().from_objects_to_file()
        - PostenMappingTemplateModifier.alter_excel_template

        Parameters
        ----------
        start_assets : Iterable[OTLObject]
            List of OTL Objects
        output_path : Path
            Output path of the generated file. (actually only Excel is supported)
        keep_original_attributes: bool
            Keep the original attributes, and do not overwrite them by the attributes from the Postmapping template
        append_all_attributes: bool
            Append all the attributes who are part of an asset. These are all the possible attributes of the asset.
        model_directory: Path
            Path to the model directory

        Returns
        -------
        None
            An Excel file is written with all the assets, generated by the type template.
        """
        if output_path.suffix != ".xlsx":
            raise NotImplementedError(f"File type '{output_path.suffix}' is not supported. Only .xlsx files are allowed.")

        template_created_assets = []
        for i, asset in enumerate(start_assets):
            template_created_assets.extend(
                self.create_assets_from_mapping(
                    asset,
                    unique_index=i,
                    keep_original_attributes=keep_original_attributes,
                    model_directory=model_directory
                )
            )

        if append_all_attributes:
            dummy_assets = create_dummy_assets(template_created_assets)
            template_created_assets.extend(dummy_assets)

        OtlmowConverter().from_objects_to_file(sequence_of_objects=template_created_assets,
                                               file_path=output_path,
                                               abbreviate_excel_sheettitles=True)

        PostenMappingTemplateModifier.alter_excel_template(
            output_path=output_path,
            instantiated_assets=template_created_assets,
            delete_dummy_records=True
        )

    def create_assets_from_mapping(self, base_asset: OTLObject, unique_index: int,
                                   keep_original_attributes: bool = True, model_directory: Path = None) -> List[OTLObject]:
        """Create assets from a mapping template

        Creates OTLObjects (assets, relations) from a base_asset and the mapping template

        Parameters
        ----------
        base_asset : OTLObject
            The base asset
        unique_index : int
            unique index
        keep_original_attributes: bool
            Keep the original attributes, and do not overwrite them by the attributes from the Postmapping template

        Returns
        -------
        List[OTLObject]
            A list of OTLObjects, the base assets, and its related assets and relations
        """
        mapping_key = self.get_valid_mapping_key_from_base_asset(base_asset)

        mapping = copy.deepcopy(self.mapping_dict[mapping_key])

        created_assets = []

        copy_base_asset = dynamic_create_instance_from_uri(base_asset.typeURI, model_directory=model_directory)
        copy_base_asset.assetId.identificator = base_asset.assetId.identificator
        copy_base_asset.assetId.toegekendDoor = base_asset.assetId.toegekendDoor
        copy_base_asset.bestekPostNummer = base_asset.bestekPostNummer
        copy_base_asset.bestekPostNummer.remove(mapping_key)

        # change the local id of the base asset to the real id in the mapping
        # and change relation id's accordingly
        base_local_id = next(
            (local_id for local_id, asset_mapping in mapping.items() if asset_mapping.get('isHoofdAsset')), None)
        for local_id, asset_mapping in mapping.items():
            if local_id == base_local_id:
                continue
            if 'bronAssetId.identificator' in asset_mapping['attributen']:
                if asset_mapping['attributen']['bronAssetId.identificator']['value'] == base_local_id:
                    asset_mapping['attributen']['bronAssetId.identificator'][
                        'value'] = base_asset.assetId.identificator
                else:
                    asset_mapping['attributen']['bronAssetId.identificator']['value'] = \
                        f"{asset_mapping['attributen']['bronAssetId.identificator']['value']}_{unique_index}"

            if 'doelAssetId.identificator' in asset_mapping['attributen']:
                if asset_mapping['attributen']['doelAssetId.identificator']['value'] == base_local_id:
                    asset_mapping['attributen']['doelAssetId.identificator'][
                        'value'] = base_asset.assetId.identificator
                else:
                    asset_mapping['attributen']['doelAssetId.identificator']['value'] = \
                        f"{asset_mapping['attributen']['doelAssetId.identificator']['value']}_{unique_index}"

        for asset_to_create in mapping.keys():
            # step1. create the asset(s) from the mapping
            if asset_to_create == base_local_id:
                # base asset
                asset = copy_base_asset
            else:
                # child-asset(s) or relations
                type_uri = mapping[asset_to_create]['typeURI']
                asset = dynamic_create_instance_from_uri(class_uri=type_uri)
                asset.assetId.identificator = f'{asset_to_create}_{unique_index}'
                if hasattr(asset, 'toestand'):
                    asset.toestand = base_asset.toestand

            # step2. create the attributes for each asset, based on the mapping dictionary
            # if base asset and parameter keep_original_attributes is set True,
            # copy the attributes from the input parameter base_asset
            # in all other cases: apply the mapping of attributes
            if asset_to_create == base_local_id and keep_original_attributes:
                # Add the original attributes from the base_asset, except from assetId, bestekPostNummer, typeURI
                base_asset_dict = create_dict_from_asset(base_asset)

                base_asset_filtered_dict = {key: value for key, value in base_asset_dict.items() if
                                            key not in {'assetId', 'bestekPostNummer', 'typeURI'}}

                for attribute_name, attribute_value in base_asset_filtered_dict.items():
                    set_value_by_dictitem(asset, attribute_name, attribute_value)

            else:
                for attr in mapping[asset_to_create]['attributen'].values():
                    if attr['dotnotation'] == 'typeURI':
                        continue
                    if attr['value'] is not None:
                        value = attr['value']
                        if attr['type'] == 'http://www.w3.org/2001/XMLSchema#decimal':
                            value = float(attr['value'])

                        DotnotationHelper.set_attribute_by_dotnotation(asset, dotnotation=attr['dotnotation'], value=value)

            # Append all assets to the list. This includes the base asset, as well as the child-assets and relations.
            created_assets.append(asset)

        return created_assets

    def create_assets_from_post(self, post: str, model_directory: Path = None) -> List[OTLObject]:
        mapping = self.mapping_dict[post]
        created_assets = []
        for asset_to_create in mapping.keys():
            type_uri = mapping[asset_to_create]['typeURI']
            asset = dynamic_create_instance_from_uri(class_uri=type_uri, model_directory=model_directory)
            created_assets.append(asset)

            for attr in mapping[asset_to_create]['attributen'].values():
                if attr['value'] is not None:
                    value = attr['value']
                    if attr['type'] == 'http://www.w3.org/2001/XMLSchema#decimal':
                        value = float(attr['value'])

                    DotnotationHelper.set_attribute_by_dotnotation(asset, dotnotation=attr['dotnotation'], value=value)
                elif attr['range'] is not None:
                    asset_atr = DotnotationHelper.get_attribute_by_dotnotation(asset, dotnotation=attr['dotnotation'],
                                                                               waarde_shortcut=True)
                    field = asset_atr.field
                    if field == FloatOrDecimalField:
                        asset_atr.field = self._create_extended_field_float_or_decimal(field, attr['range'])
                    elif issubclass(field, KeuzelijstField):
                        asset_atr.field = self._create_extended_field_keuzelijst(field, attr['range'])
                    else:
                        raise NotImplementedError(f'Not implemented for {field}')

        return created_assets

    def _create_extended_field_float_or_decimal(self, field, range_str: str) -> object:
        extended_field = type(f'Extended{field.__name__}', (field, object), field.__dict__.copy())
        extended_field.super_class = field

        conditions = self._split_numeric_range_str(range_str)

        def validate(value, attribuut, cls=extended_field):
            s = cls.super_class
            base_validate = s.validate(value, attribuut)
            if not base_validate:
                return base_validate

            if len(conditions) == 1:
                if conditions[0][0] == 'st':
                    return value < conditions[0][1]
                elif conditions[0][0] == 'ste':
                    return value <= conditions[0][1]
                elif conditions[0][0] == 'gt':
                    return value > conditions[0][1]
                elif conditions[0][0] == 'gte':
                    return value >= conditions[0][1]
            elif len(conditions) == 2:
                if conditions[0][0] == 'gt' and conditions[1][0] == 'st':
                    return conditions[0][1] < value < conditions[1][1]
                elif conditions[0][0] == 'gte' and conditions[1][0] == 'st':
                    return conditions[0][1] <= value < conditions[1][1]
                elif conditions[0][0] == 'gt' and conditions[1][0] == 'ste':
                    return conditions[0][1] < value <= conditions[1][1]
                elif conditions[0][0] == 'gte' and conditions[1][0] == 'ste':
                    return conditions[0][1] <= value <= conditions[1][1]

        extended_field.validate = validate
        return extended_field

    @staticmethod
    def _write_and_return_mapping_dict(posten_mapping_path: Path, mapping_name: str, directory: Path = None) -> Dict:
        reader = SQLDbReader(posten_mapping_path)
        version = reader.perform_read_query(
            """SELECT waarde
            FROM GeneralInfo
            WHERE parameter = 'Version'""",
            {})[0][0]

        data = reader.perform_read_query(
            """SELECT code, typeURI, attribuutURI, dotnotatie, dataTypeURI, defaultWaarde, bereik, 
                usageNote, isMeetstaatAttribuut, altijdInTeVullen, isBasisMapping, mappingStatus, mappingOpmerking, tempId, 
                isHoofdAsset, unionTypeCriterium
            FROM Mapping
            WHERE isBasisMapping = '1'""",
            {})

        mapping_dict = {'version': version}
        for row in data:
            mapping_code, type_uri = str(row[0]), str(row[1])
            temp_id = str(row[13])

            if mapping_code not in mapping_dict:
                mapping_dict[mapping_code] = {}

            if temp_id not in mapping_dict[mapping_code]:
                mapping_dict[mapping_code][temp_id] = {'typeURI': type_uri, 'attributen': {}}

            mapping_dict[mapping_code][temp_id]['isHoofdAsset'] = (row[14] == 1)

            attr_uri = str(row[2])
            if attr_uri != 'None':
                dotnot_str = str(row[3])
                type_str = str(row[4])
                waarde_str = str(row[5])
                if waarde_str == 'None':
                    waarde_str = None
                bereik_str = str(row[6])
                if bereik_str == 'None':
                    bereik_str = None
                union_type_criterium_str = str(row[15])
                if union_type_criterium_str == 'None':
                    union_type_criterium_str = None

                mapping_dict[mapping_code][temp_id]['attributen'][dotnot_str] = {
                    'typeURI': attr_uri,
                    'dotnotation': dotnot_str,
                    'type': type_str,
                    'value': waarde_str,
                    'range': bereik_str,
                    'union_type_criterium': union_type_criterium_str
                }

        PostAssetFactory._write_posten_mapping(mapping_dict=mapping_dict, directory=directory,
                                               mapping_name=mapping_name)

        return mapping_dict

    @staticmethod
    def _split_numeric_range_str(range_str: str) -> []:
        if range_str == '' or range_str is None or 'x' not in range_str:
            return []

        splitted = range_str.split(' ')
        conditions = []

        if splitted[2] == 'x':
            if splitted[1] == '<':
                conditions.append(('gt', float(splitted[0])))
            elif splitted[1] == '<=':
                conditions.append(('gte', float(splitted[0])))
            if len(splitted) > 3:
                if splitted[3] == '<':
                    conditions.append(('st', float(splitted[4])))
                elif splitted[3] == '<=':
                    conditions.append(('ste', float(splitted[4])))
        elif splitted[0] == 'x':
            if splitted[1] == '<':
                conditions.append(('st', float(splitted[2])))
            elif splitted[1] == '<=':
                conditions.append(('ste', float(splitted[2])))

        return conditions

    @staticmethod
    def _create_extended_field_keuzelijst(field, range_str) -> object:
        extended_field = type('Extended' + field.__name__, (field, object), field.__dict__.copy())
        extended_field.super_class = field
        extended_field.options = {}

        field_options = field.options

        if '|' in range_str:
            valid_options = range_str.split('|')
        else:
            valid_options = [range_str]

        for option in valid_options:
            extended_field.options[option] = field_options[option]

        return extended_field

    @staticmethod
    def _write_posten_mapping(mapping_dict: dict, mapping_name: str, directory: Path = None) -> None:
        posten_mapping_str = json.dumps(mapping_dict, indent=4)
        file_dir = directory
        if file_dir is None:
            file_dir = Path(__file__).parent
        file_path = file_dir / f'{mapping_name}Dict.py'
        with open(file_path, "w") as file:
            file.write(f'class {mapping_name}Dict:\n    mapping_dict = ' + posten_mapping_str.replace('null', 'None').
                       replace('true', 'True').replace('false', 'False'))
